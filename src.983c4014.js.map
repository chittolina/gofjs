{"version":3,"sources":["lib/algorithms.js","GameOfLife.js","index.js"],"names":["getNeighbors","x","y","map","mapConstraints","length","getNewCellState","currentMapState","nearbyLivingCells","i","j","filter","neighbor","currentState","newState","getNewState","createBoard","dimensions","newCellState","random","board","value","Math","round","GameOfLife","interval","element","timer","setInterval","tick","running","clearInterval","pause","currentGeneration","updateBoard","event","target","start","clear","ctx","canvas","getContext","clearRect","width","height","xFactor","yFactor","fillStyle","fillRect","document","getElementById","innerHTML","rect","getBoundingClientRect","clientX","left","clientY","top","scaledX","floor","scaledY","container","querySelector","createElement","appendChild","canvasWidth","canvasHeight","addEventListener","onCellClick","startButton","pauseButton","clearButton","randomButton","intervalSlider","gameOfLife","changeInterval"],"mappings":"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","file":"src.983c4014.js","sourceRoot":"../src","sourcesContent":["/**\n *  Algorithms module. Contains algorithms used to implement the game created by John Horton Conway.\n * @module src/lib/algorithms\n */\n\n/**\n * Gets the neighbors positions for the given x and y position\n * @param {number} x The x coordinate\n * @param {number} y The y coordinate\n * @param {Array<Array<number>>} The current map\n * @return {Array<Array<number>>} An array with the found neighbors positions\n */\nconst getNeighbors = (x, y, map) => {\n  const mapConstraints = [map[0].length - 1, map[1].length - 1]\n  // 1. Corner cases\n  // 1.1 Bottom left corner\n  if (x == 0 && y == 0) {\n    return [\n      [0, 1],\n      [1, 1],\n      [1, 0],\n    ]\n  }\n  // 1.2 Bottom right corner\n  if (x == mapConstraints[0] && y == 0) {\n    return [\n      [mapConstraints[0] - 1, 0],\n      [mapConstraints[0] - 1, 1],\n      [mapConstraints[0], 1],\n    ]\n  }\n  // 1.3 Top left corner\n  if (x == 0 && y == mapConstraints[1]) {\n    return [\n      [0, mapConstraints[1] - 1],\n      [1, mapConstraints[1] - 1],\n      [1, mapConstraints[1]],\n    ]\n  }\n  // 1.4 Top right corner\n  if (x == mapConstraints[0] && y == mapConstraints[1]) {\n    return [\n      [mapConstraints[0] - 1, mapConstraints[1]],\n      [mapConstraints[0] - 1, mapConstraints[1] - 1],\n      [mapConstraints[0], mapConstraints[1] - 1],\n    ]\n  }\n\n  // 2. Handle extreme left, right, top and bottom cells\n  // 2.1 Left\n  if (x == 0) {\n    return [\n      [x, y - 1],\n      [x + 1, y - 1],\n      [x + 1, y],\n      [x + 1, y + 1],\n      [x, y + 1],\n    ]\n  }\n  // 2.2 Right\n  if (x == mapConstraints[0]) {\n    return [\n      [x, y - 1],\n      [x - 1, y - 1],\n      [x - 1, y],\n      [x - 1, y + 1],\n      [x, y + 1],\n    ]\n  }\n  // 2.3 Top\n  if (y == mapConstraints[1]) {\n    return [\n      [x + 1, y],\n      [x + 1, y - 1],\n      [x, y - 1],\n      [x - 1, y - 1],\n      [x - 1, y],\n    ]\n  }\n  // 2.4 Bottom\n  if (y == 0) {\n    return [\n      [x - 1, 0],\n      [x - 1, y + 1],\n      [x, y + 1],\n      [x + 1, y + 1],\n      [x + 1, y],\n    ]\n  }\n\n  // 3. Generic case\n  return [\n    [x - 1, y],\n    [x - 1, y + 1],\n    [x - 1, y - 1],\n    [x + 1, y],\n    [x + 1, y + 1],\n    [x + 1, y - 1],\n    [x, y + 1],\n    [x, y - 1],\n  ]\n}\n\n/**\n * Gets the new cell state\n * @param {number} cellPosition The cell position\n * @param {Array<number>} currentMapState An array with the current map state\n * @return {number} The new cell state.\n */\nconst getNewCellState = ([x, y] = [], currentMapState) => {\n  const neighbors = getNeighbors(x, y, currentMapState).map(\n    ([i, j]) => currentMapState[i][j],\n  )\n\n  const nearbyLivingCells = neighbors.filter(neighbor => neighbor === 1).length\n  let currentState = currentMapState[x][y]\n  let newState = currentState\n\n  if (currentState == 0 && nearbyLivingCells === 3) {\n    newState = 1\n  }\n  if (currentState === 1) {\n    if (nearbyLivingCells === 2 || nearbyLivingCells === 3) {\n      newState = 1\n    }\n    if (nearbyLivingCells < 2 || nearbyLivingCells > 3) {\n      newState = 0\n    }\n  }\n\n  return newState\n}\n\n/**\n * Gets the new map state\n * @param {Array<Array<number>>} currentMapState The current map state\n * @return {Array<Array<number>>} The new map state\n */\nconst getNewState = currentMapState => {\n  const newState = createBoard({\n    dimensions: [currentMapState.length, currentMapState[0].length],\n  })\n\n  for (let i = 0; i < newState.length; i++) {\n    for (let j = 0; j < newState[0].length; j++) {\n      const newCellState = getNewCellState([i, j], currentMapState)\n\n      newState[i][j] = newCellState\n    }\n  }\n\n  return newState\n}\n\n/**\n * Creates a new board\n * @param {Object} params The params object\n * @param {Array<number>} [params.dimensions=[]] The desired x and y dimensions\n * @param {boolean} [params.random=false] Whether to generate random values or not\n * @return {Array<Array<number>>} The created board\n */\nconst createBoard = ({ dimensions: [x, y] = [], random = false }) => {\n  let board = []\n\n  for (let i = 0; i < x; i++) {\n    board[i] = []\n    for (let j = 0; j < y; j++) {\n      const value = random ? Math.round(Math.random()) : 0\n      board[i][j] = value\n    }\n  }\n\n  return board\n}\n\nexport { createBoard, getNeighbors, getNewState, getNewCellState }\n","import { createBoard, getNewState } from './lib/algorithms'\n\nexport default class GameOfLife {\n  /**\n   * Creates a new board of GameOfLife\n   * @param {Object} params Parameters object\n   * @param {Array<Array>} params.dimensions The map dimensions\n   * @param {number} params.interval The interval between generations\n   * @param {string} params.element The query selector of the element to use as a container for the board\n   */\n  constructor({ dimensions, interval, element }) {\n    this.dimensions = dimensions\n    this.interval = interval\n    this.timer = null\n\n    this.running = false\n    this.currentState = createBoard({\n      dimensions: [dimensions[0], dimensions[1]],\n    })\n    this.currentGeneration = 0\n\n    this.container = document.querySelector(element)\n    this.canvas = document.createElement('canvas')\n    this.container.appendChild(this.canvas)\n    this.canvasWidth = 1000\n    this.canvasHeight = 1000\n\n    // Factors used to scale the given dimensions to the canvas size\n    this.xFactor = this.canvasWidth / dimensions[0]\n    this.yFactor = this.canvasHeight / dimensions[1]\n\n    this.canvas.width = this.canvasWidth\n    this.canvas.height = this.canvasHeight\n\n    this.canvas.addEventListener('click', this.onCellClick)\n\n    this.random()\n    this.updateBoard()\n  }\n\n  /**\n   * Starts the game\n   */\n  start = () => {\n    if (!this.timer) {\n      this.timer = setInterval(this.tick, this.interval)\n      this.running = true\n    }\n  }\n\n  /**\n   * Pauses the game\n   */\n  pause = () => {\n    clearInterval(this.timer)\n    this.timer = null\n    this.running = false\n  }\n\n  /**\n   * Pauses the game and clears the map\n   */\n  clear = () => {\n    this.pause()\n    this.currentState = createBoard({\n      dimensions: [this.dimensions[0], this.dimensions[1]],\n    })\n    this.currentGeneration = 0\n    this.updateBoard()\n  }\n\n  /**\n   * Changes the current tick interval\n   * @param {Event} event The input event received by the slider\n   */\n  changeInterval = event => {\n    const {\n      target: { value: interval },\n    } = event\n    this.interval = interval\n\n    if (this.running) {\n      this.pause()\n      this.start()\n    }\n  }\n\n  /**\n   * Generates a random pattern on the map\n   */\n  random = () => {\n    this.clear()\n    this.currentState = createBoard({\n      dimensions: [this.dimensions[0], this.dimensions[1]],\n      random: true,\n    })\n    this.currentGeneration = 0\n    this.updateBoard()\n  }\n\n  /**\n   * Ticks the game (gets the next generation and updates the map)\n   */\n  tick = () => {\n    const newState = getNewState(this.currentState)\n    this.currentState = newState\n    this.currentGeneration++\n\n    this.updateBoard()\n  }\n\n  /**\n   * Updates the board accordingly to the current state\n   */\n  updateBoard = () => {\n    const ctx = this.canvas.getContext('2d')\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    const { currentState, currentGeneration, xFactor, yFactor } = this\n    for (let i = 0; i < currentState.length; i++) {\n      for (let j = 0; j < currentState[0].length; j++) {\n        if (currentState[i][j] === 1) {\n          // If cell is alive\n          ctx.fillStyle = '#581845'\n          ctx.fillRect(i * xFactor, j * yFactor, xFactor, yFactor)\n        } else {\n          // If cell is dead\n          ctx.fillStyle = '#900C3F'\n          ctx.fillRect(i * xFactor, j * yFactor, xFactor, yFactor)\n        }\n      }\n    }\n\n    document.getElementById('generation-count').innerHTML = currentGeneration\n  }\n\n  /**\n   * Callback called to update the board after clicking on a cell.\n   * If the game is currently running this method has no effect.\n   * @param event The click event\n   */\n  onCellClick = event => {\n    if (this.running) {\n      return\n    }\n\n    const rect = this.canvas.getBoundingClientRect()\n\n    const x = event.clientX - rect.left\n    const y = event.clientY - rect.top\n\n    // Map the received values to our original map size\n    const scaledX = Math.floor(x / this.xFactor)\n    const scaledY = Math.floor(y / this.yFactor)\n\n    const newState = [...this.currentState]\n    newState[scaledX][scaledY] = 1 - newState[scaledX][scaledY]\n\n    this.currentState = newState\n    this.updateBoard()\n  }\n}\n","import GameOfLife from './GameOfLife'\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const startButton = document.getElementById('start')\n  const pauseButton = document.getElementById('pause')\n  const clearButton = document.getElementById('clear')\n  const randomButton = document.getElementById('random')\n  const intervalSlider = document.getElementById('interval')\n\n  const gameOfLife = new GameOfLife({\n    dimensions: [100, 100],\n    interval: 10,\n    element: '#board',\n  })\n\n  startButton.addEventListener('click', gameOfLife.start)\n  pauseButton.addEventListener('click', gameOfLife.pause)\n  clearButton.addEventListener('click', gameOfLife.clear)\n  randomButton.addEventListener('click', gameOfLife.random)\n  intervalSlider.addEventListener('input', gameOfLife.changeInterval)\n})\n"]}